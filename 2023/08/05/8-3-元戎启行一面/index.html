<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="John Doe">





<title>8-3-元戎启行一面 | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
            <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">ZH&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">ZH&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">8-3-元戎启行一面</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">John Doe</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">August 5, 2023&nbsp;&nbsp;19:30:26</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>秋招面试的第一个公司：元戎启行。面试官的摄像头有问题没有样子，不过听声音感觉很温和，无法开摄像头和接电话后和我道歉，给予了足够的尊重。说明这个公司的文化就尊重每个人，而且注重生活。面试的结果我觉得很不好，最后他还安慰我说不要因为一场面试就否定自己，还鼓励我多学习，真是个好人。</p>
<ol>
<li><p><strong>C++11,14,17都有哪些特性</strong></p>
<p>C++ 11：auto,decltype类型推导，返回值类型后置（跟踪返回值类型），模板连续右尖括号&gt;&gt;的改进，using定义别名，函数模板的默认模板参数，函数模板和类模板中使用可变参数，tuple元组，列表初始化，lambda匿名函数，非受限联合体，基于范围的for循环，constexpr，long long，右值引用，移动构造函数，std:move，引用限定符，完美转发，nullptr，智能指针</p>
<p><strong>类型推导</strong></p>
<ol>
<li><p>auto<br>占位符，类型变量类型由编译器推导得出。<br>当推导类型包含引用时会抛弃引用，直接推导出原始类型。<br>与const：当类型不为引用时，auto 的推导结果将不保留表达式的 const 属性。当类型为引用时，auto 的推导结果将保留表达式的 const 属性。<br><strong>限制</strong>：不能在函数的参数中使用。 不能作用于类的非静态成员变量。不能定义数组。不能作用于模板参数。</p>
</li>
<li><p>decltype<br><code>decltype(exp) varname = value;</code><br>根据表达式推导出类型。auto 要求变量必须初始化，而 decltype 不要求。</p>
<p>如果 exp 是一个不被括号<code>( )</code>包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。</p>
<p>如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。</p>
<p>如果 exp 是一个左值，或者被括号<code>( )</code>包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&amp;。</p>
</li>
</ol>
<p><strong>返回值类型后置</strong></p>
<p>在泛型编程中，可能需要通过参数的运算来得到返回值的类型。</p>
<p>通过 auto 和 decltype 结合起来使用实现返回类型后置，从而解决在返回值定义时参数变量还不存在无法从运算表达式进行类型推导的问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>模板&gt;&gt;改进</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo&lt;A&lt;<span class="type">int</span>&gt;&gt;::type xx;  <span class="comment">//编译出错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对模板的<code>&gt;&gt;</code>进行单独处理，从而允许在模板中的<code>&gt;&gt;</code>不被编译器错认为右移运算符。</p>
<p><strong>using别名</strong>，替代typedef</p>
<p><code>typedef unsigned int uint_t;</code></p>
<p>typedef 重定义一个类型，给原有的类型取了一个新的名字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* C++98/03 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*type)</span><span class="params">(T, T)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用 func_t 模板</span></span><br><span class="line"><span class="type">func_t</span>&lt;<span class="type">int</span>&gt;::type xx_1;</span><br><span class="line"><span class="comment">/* C++11 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = <span class="built_in">void</span> (*)(T, T);</span><br><span class="line"><span class="comment">// 使用 func_t 模板</span></span><br><span class="line"><span class="type">func_t</span>&lt;<span class="type">int</span>&gt; xx_2;</span><br></pre></td></tr></table></figure>



<p><strong>函数模板的默认模板参数</strong></p>
<p>类模板可以有默认参数，c++11新增函数模板也可以。</p>
<p>当所有模板参数都有默认参数时，函数模板的调用如同一个普通函数。但对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随<code>&lt;&gt;</code>来实例化。</p>
<p>默认模板参数和编译器自行推导出模板参数类型的能力可以结合使用，指定函数中的一部分模板参数采用默认参数，而另一部分使用自动推导。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R = <span class="type">int</span>, <span class="keyword">typename</span> U&gt;</span><br><span class="line">R <span class="built_in">func</span>(U val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">97</span>);               <span class="comment">// R=int, U=int</span></span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">char</span>&gt;(<span class="number">97</span>);         <span class="comment">// R=char, U=int</span></span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">double</span>, <span class="type">int</span>&gt;(<span class="number">97</span>);  <span class="comment">// R=double, U=int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>函数模板和类模板中使用可变参数</strong></p>
<p><code>template&lt;typename... Types&gt;</code></p>
<p>可接纳的模板参数个数是<strong>0</strong>个及以上。</p>
<p>如果希望必须有一个模板参数，</p>
<p><code>template&lt;typename Head, typename ... Tail&gt;</code></p>
<p>用法：递归取出参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这个空的print，用于处理最后一个</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; firstArg, <span class="type">const</span> Types&amp;... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; firstArg &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">print</span>(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<code>...</code>的位置</p>
<p><strong>tuple元组</strong></p>
<p>实例化的对象可以存储任意数量、任意类型的数据。</p>
<p>tuple 本质是一个以可变模板参数定义的类模板。</p>
<p><strong>列表初始化</strong></p>
<p>POD ： plain old data 类型，简单来说，是可以直接使用 memcpy 复制的对象。</p>
<p>对于普通数据和POD类型，可以直接用初始列列表进行初始化。C++11将其扩大到任意类型对象的初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">a1</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br><span class="line">    Foo a2 = <span class="number">123</span>;  <span class="comment">//error: &#x27;Foo::Foo(const Foo &amp;)&#x27; is private</span></span><br><span class="line">    Foo a3 = &#123; <span class="number">123</span> &#125;;</span><br><span class="line">    Foo a4 &#123; <span class="number">123</span> &#125;;</span><br><span class="line">    <span class="type">int</span> a5 = &#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="type">int</span> a6 &#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>new操作符可以用圆括号进行初始化的地方也可以用初始化列表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span> &#123; <span class="number">123</span> &#125;;</span><br><span class="line"><span class="type">double</span> b = <span class="type">double</span> &#123; <span class="number">12.12</span> &#125;;</span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>列表初始化还可以直接使用在函数的返回值上。</p>
<p><strong>lambda匿名函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[外部变量访问方式说明符] (参数) mutable noexcept/throw() -&gt; 返回值类型</span><br><span class="line">&#123;</span><br><span class="line">  函数体;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[]表示捕获外部变量，[&#x3D;]值捕获外部所有变量，[&amp;]引用捕获外部所有变量，[v1,v2]值捕获v1和v2，[&amp;v1,&amp;v2]引用捕获v1和v2，[v1,&amp;v2]值捕获v1引用捕获v2，[&#x3D;,&amp;v2]引用捕获v2其他值捕获，[this]值捕获this指针。</p>
<p>参数类型函数定义的形参。</p>
<p>mutable表示可以对捕获的值进行修改，没有就默认为const。</p>
<p>noexcept&#x2F;throw()可以省略。noexcept表示不会抛出任何异常。throw()可以指定可以抛出的异常类型。这两个关键字会导致异常无法被try-catch捕获。默认可以抛出所有异常。</p>
<p>-&gt;返回值类型，如果函数体中只有一个return或者返货void，可以省略，编译器自动推导。</p>
<p>lambda表示式可以访问全局变量。</p>
<p><strong>非受限联合体</strong></p>
<p>C++11 标准规定，任何非引用类型（POD、非POD、静态成员(只能在联合体内使用)）都可以成为联合体的数据成员，这种联合体也被称为非受限联合体。</p>
<p>如果非受限联合体内有一个非 POD 的成员，而该成员拥有自定义的构造函数，那么这个非受限联合体的默认构造函数将被编译器删除；其他的特殊成员函数，例如默认拷贝构造函数、拷贝赋值操作符以及析构函数等，也将被删除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">U</span> &#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;   <span class="comment">// 构造失败，因为 U 的构造函数被删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决这个问题的一般需要用到 <strong>placement new</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">U</span> &#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">U</span>() &#123; <span class="keyword">new</span>(&amp;s) string; &#125;</span><br><span class="line">    ~<span class="built_in">U</span>() &#123; s.~<span class="built_in">string</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用 placement new 将 s <strong>构造在其地址 &amp;s</strong> 上，这里 placement new 的唯一作用只是调用了一下 string 类的构造函数。注意，在析构时还需要调用 string 类的析构函数。</p>
<p><strong>placement new</strong> 是什么</p>
<p>placement new 是 new 关键字的一种进阶用法，既可以在栈（stack）上生成对象，也可以在堆（heap）上生成对象。相对应地，我们把常见的 new 的用法称为 operator new，它只能在 heap 上生成对象。</p>
<p><code>new(address) ClassConstruct(...)</code></p>
<p>placement new 利用已经申请好的内存来生成对象，它不再为对象分配新的内存，而是将对象数据放在 address 指定的内存中。</p>
<p>匿名联合体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">U</span>&#123;</span><br><span class="line">    <span class="keyword">union</span> &#123; <span class="type">int</span> x; &#125;;  <span class="comment">//此联合体为匿名联合体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>非受限联合体也可以匿名，而当非受限的匿名联合体运用于类的声明时，这样的类被称为“枚举式类”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">bool</span> g, <span class="type">int</span> a): <span class="built_in">gender</span>(g), <span class="built_in">age</span>(a)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> gender;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Type</span> &#123; STUDENT, NATIVE, FOREIGENR &#125;;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="type">bool</span> g, <span class="type">int</span> a) : <span class="built_in">s</span>(g, a) &#123; t = STUDENT; &#125;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="type">int</span> i) : <span class="built_in">id</span>(i) &#123; t = NATIVE; &#125;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="type">const</span> <span class="type">char</span>* n, <span class="type">int</span> s) &#123;</span><br><span class="line">        <span class="type">int</span> size = (s &gt; <span class="number">9</span>) ? <span class="number">9</span> : s;</span><br><span class="line">        <span class="built_in">memcpy</span>(name , n, size);</span><br><span class="line">        name[s] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        t = FOREIGENR;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Singer</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type t;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Student s;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="literal">true</span>, <span class="number">13</span>);</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="number">310217</span>);</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="string">&quot;J Michael&quot;</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>基于范围的for循环</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x: myvector)&#123;</span><br><span class="line">	cout &lt;&lt; x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果需要修改</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> &amp;x: myvector)&#123;</span><br><span class="line">	cout &lt;&lt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>constexpr</strong></p>
<p>常量表达式，指的就是由多个（≥1）常量组成的表达式。</p>
<p>constexpr 关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。C++ 11 标准中，constexpr 可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。注意，获得在编译阶段计算出结果的能力，并不代表 constexpr 修饰的表达式一定会在程序编译阶段被执行，具体的计算时机还是编译器说了算。</p>
<p>修饰普通变量：变量必须经过初始化且初始值必须是一个常量表达式。</p>
<p>修饰函数：这样的函数又称为“常量表达式函数”。必须满足：</p>
<ol>
<li>整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，只能包含一条 return 返回语句。</li>
<li>该函数必须有返回值，即函数的返回值类型不能是 void。</li>
<li>函数在使用之前，必须有对应的定义语句。我们知道，函数的使用分为“声明”和“定义”两部分，普通的函数调用只需要提前写好该函数的声明部分即可（函数的定义部分可以放在调用位置之后甚至其它文件中），但常量表达式函数在使用前，必须要有该函数的定义。</li>
<li>return 返回的表达式必须是常量表达式。</li>
</ol>
<p>修饰类的构造函数：C++ 内置类型的数据，可以直接用 constexpr 修饰。自定义的数据类型，需要添加一个常量构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myType</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">myType</span><span class="params">(<span class="type">char</span> *name,<span class="type">int</span> age)</span>:name(name),age(age)&#123;</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> mt &#123; <span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    cout &lt;&lt; mt.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mt.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，constexpr 修饰类的构造函数时，要求该构造函数的函数体必须为空，且采用初始化列表的方式为各个成员赋值时，必须使用常量表达式。C++11 标准中，不支持用 constexpr 修饰带有 virtual 的成员方法</p>
<p>constexpr 也可以修饰类中的成员函数，只不过此函数必须满足前面提到的 4 个条件。</p>
<p>修饰模板函数：C++11 标准规定，如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。</p>
<p><strong>long long</strong></p>
<table>
<thead>
<tr>
<th>整数类型</th>
<th>等价类型</th>
<th>C++11标准规定占用最少位数</th>
</tr>
</thead>
<tbody><tr>
<td>short</td>
<td>short int（有符号短整型）</td>
<td>至少 16 位（2 个字节）</td>
</tr>
<tr>
<td>signed short</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed short int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>unsigned short</td>
<td>unsigned short int（无符号短整型）</td>
<td></td>
</tr>
<tr>
<td>unsigned short int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>int</td>
<td>int（有符号整形）</td>
<td>至少 16 位（2 个字节）</td>
</tr>
<tr>
<td>signed</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>unsigned</td>
<td>unsigned int（无符号整形）</td>
<td></td>
</tr>
<tr>
<td>unsigned int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>long</td>
<td>long int（有符号长整形）</td>
<td>至少 32 位（4 个字节）</td>
</tr>
<tr>
<td>long int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed long</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed long int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>unsigned long</td>
<td>unsigned long int（无符号长整形）</td>
<td></td>
</tr>
<tr>
<td>unsigned long int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>long long（C++11）</td>
<td>long long int（有符号超长整形）</td>
<td>至少 64 位（8 个字节）</td>
</tr>
<tr>
<td>long long int（C++11）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed long long（C++11）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed long long int（C++11）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>unsigned long long（C++11）</td>
<td>unsigned long long int（无符号超长整型）</td>
<td></td>
</tr>
<tr>
<td>unsigned long long int（C++11）</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>右值引用</strong></p>
<ol>
<li>可位于赋值号（&#x3D;）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。</li>
<li>有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。</li>
</ol>
<p><strong>右值引用也必须立即进行初始化操作，且只能使用右值进行初始化。</strong></p>
<p><strong>移动构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动构造函数</span></span><br><span class="line">	<span class="comment">// 和复制构造函数的区别在于，其参数是右值引用</span></span><br><span class="line">	<span class="built_in">String</span>(String &amp;&amp; s) : <span class="built_in">str</span>(s.str)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		s.str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">		s.str[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 移动赋值运算符</span></span><br><span class="line">	<span class="comment">// 和复制赋值运算符的区别在于，其参数是右值引用</span></span><br><span class="line">	String &amp; <span class="keyword">operator</span> = (String &amp;&amp; s)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用移动赋值运算符&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (str != s.str)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 在移动赋值运算符函数中没有执行深复制操作，</span></span><br><span class="line">			<span class="comment">// 而是直接将对象的 str 指向了参数 s 的成员变量 str 指向的地方，</span></span><br><span class="line">			<span class="comment">// 然后修改 s.str 让它指向别处，以免 s.str 原来指向的空间被释放两次。</span></span><br><span class="line">			str = s.str;</span><br><span class="line">			s.str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">			s.str[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p><strong>std:move</strong></p>
<p>将某个左值强制转化为右值,常用于实现移动语义。</p>
<p><strong>引用限定符</strong></p>
<p>默认情况下，对于类中用 public 修饰的成员函数，既可以被左值对象调用，也可以被右值对象调用。</p>
<p>某些场景中，我们可能需要<strong>限制调用成员函数的对象的类型</strong>（左值还是右值），为此 C++11 新添加了引用限定符。所谓引用限定符，就是在成员函数的后面添加 “&amp;” 或者 “&amp;&amp;”，从而限制调用者的类型（左值还是右值）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">int</span> num):<span class="built_in">num</span>(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span>&amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">get_num</span>() &lt;&lt; endl;          <span class="comment">// 正确</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; move(a).get_num() &lt;&lt; endl;  // 错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">int</span> num):<span class="built_in">num</span>(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span>&amp;&amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; a.get_num() &lt;&lt; endl;      // 错误</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num</span>() &lt;&lt; endl;  <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>完美转发</strong></p>
<p>完美转发是指在函数模板中，将参数按照原样转发给另一个函数，并保持参数的值类别不变。</p>
<p>通过将函数模板的形参类型设置为 T&amp;&amp;，通过引用折叠可以很好地解决接收左、右值的问题。在模板内部，不管是右值引用还是左值引用，本身都是左值，因此需要std::forward&lt;T&gt;()进行左右值属性连同形参一期传递给被调用的函数。</p>
<p>源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function">    <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  @brief  Forward an rvalue.</span></span><br><span class="line"><span class="comment">   *  @return The parameter cast to the specified type.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *  This function is used to implement &quot;perfect forwarding&quot;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function">    <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="built_in">static_assert</span>(!std::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">&quot;template argument&quot;</span></span><br><span class="line">		    <span class="string">&quot; substituting _Tp is an lvalue reference type&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果传入参数是string&amp;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string&amp; &amp;&amp;引用折叠为string&amp;</span></span><br><span class="line"><span class="comment">//std::remove_reference提取出的类型为string</span></span><br><span class="line"><span class="function">string&amp;</span></span><br><span class="line"><span class="function"><span class="title">forward</span><span class="params">(string&amp; <span class="type">__t</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;string&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string&amp;</span></span><br><span class="line"><span class="function">    <span class="title">forward</span><span class="params">(string&amp;&amp; <span class="type">__t</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//忽略此处的静态断言</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;string&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果传入参数是string&amp;&amp;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string&amp;&amp; &amp;&amp;引用折叠为string&amp;&amp;</span></span><br><span class="line"><span class="comment">//std::remove_reference提取出的类型为string</span></span><br><span class="line"><span class="function">string&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">forward</span><span class="params">(string&amp; <span class="type">__t</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;string&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string&amp;&amp;</span></span><br><span class="line"><span class="function">    <span class="title">forward</span><span class="params">(string&amp;&amp; <span class="type">__t</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//忽略此处的静态断言</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;string&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>nullptr</strong></p>
<p>NULL不是关键字，而是事先定义好的宏，值为0。在函数重载时，指针初始化为NULL会被错认为整型0。</p>
<p>nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象。nullptr 可以被隐式转换成任意的指针类型。</p>
<p><strong>智能指针</strong></p>
<p>避免内存泄漏、悬空指针、方便资源共享，引入智能指针。</p>
<ol>
<li><code>std::unique_ptr</code>：<code>std::unique_ptr</code>实现了独占所有权的智能指针。每个<code>std::unique_ptr</code>对象拥有对其所管理的对象的唯一所有权。当<code>std::unique_ptr</code>对象超出作用域时，它会自动释放所管理的对象。<code>std::unique_ptr</code>不能被复制，但可以通过移动语义来转移所有权。</li>
<li><code>std::shared_ptr</code>：<code>std::shared_ptr</code>实现了共享所有权的智能指针。多个<code>std::shared_ptr</code>对象可以共享同一个对象，并且在最后一个<code>std::shared_ptr</code>对象超出作用域时，才会释放所管理的对象。<code>std::shared_ptr</code>使用引用计数的方式来跟踪有多少个<code>std::shared_ptr</code>对象指向同一个对象，当引用计数为0时，释放内存。</li>
<li><code>std::weak_ptr</code>: 是一种弱引用，它可以观测一个<code>std::shared_ptr</code>所管理的对象，但不会增加对象的引用计数。当最后一个<code>std::shared_ptr</code>对象超出作用域时，被观测的<code>std::weak_ptr</code>会自动失效。<code>std::weak_ptr</code>的主要用途是解决循环引用问题。当多个对象之间存在循环引用时，可以使用<code>std::weak_ptr</code>来打破循环引用，从而正确释放内存。通过将其中一个<code>std::shared_ptr</code>对象替换为<code>std::weak_ptr</code>，可以确保循环引用不会导致内存泄漏。<code>std::weak_ptr</code>不能直接访问被观测的对象，必须通过<code>lock()</code>函数获取一个有效的<code>std::shared_ptr</code>才能访问。此外，由于<code>std::weak_ptr</code>不会增加引用计数，所以需要注意在使用<code>std::weak_ptr</code>时，被观测的对象可能已经被释放的情况。</li>
</ol>
<hr>
<p>C++ 14：变量模板，泛型lambda表达式，更宽松的constexpr限制，返回值自动类型推导，二进制字面量，std::make_unique，std::exchange</p>
<p><strong>变量模板</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T pi = <span class="built_in">T</span>(<span class="number">3.1415926535897932385L</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; pi&lt;<span class="type">int</span>&gt; &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line">    cout &lt;&lt; pi&lt;<span class="type">double</span>&gt; &lt;&lt; endl; <span class="comment">// 3.14159</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>泛型lambda表达式</strong></p>
</li>
</ol>
<p>lambda中的形参可以用auto</p>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lam = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>更宽松的constexpr限制</strong></p>
<p> 在C++14中可以使用局部变量和循环，无需放在一个return里</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="comment">// C++11中不可，C++14中可以</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ret += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>返回值自动类型推导</strong></p>
<p>auto可以作为函数的返回类型，由编译器进行推导</p>
<p>注意：</p>
<ul>
<li>函数内如果有多个return语句，它们必须返回相同的类型，否则编译失败。</li>
<li>如果return语句返回初始化列表，返回值类型推导也会失败</li>
<li>如果函数是虚函数，不能使用返回值类型推导</li>
<li>返回类型推导可以用在前向声明中，但是在使用它们之前，翻译单元中必须能够得到函数定义</li>
<li>返回类型推导可以用在递归函数中，但是递归调用必须以至少一个返回语句作为先导，以便编译器推导出返回类型。</li>
</ul>
<p><strong>二进制字面量</strong></p>
<p>C++14引入了二进制字面量，也引入了分隔符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0b0001&#x27;0011&#x27;1010</span>;</span><br><span class="line"><span class="type">double</span> b = <span class="number">3.14&#x27;1234&#x27;1234&#x27;1234</span>;</span><br></pre></td></tr></table></figure>

<p><strong>std::make_unique</strong></p>
<p>C++11中有std::make_shared，却没有std::make_unique，在C++14已经改善。</p>
<p><strong>std::shared_timed_mutex与std::shared_lock</strong></p>
<p>C++14通过std::shared_timed_mutex和std::shared_lock来实现读写锁，保证多个线程可以同时读，但是写线程必须独立运行，写操作不可以同时和读操作一起进行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line">    <span class="keyword">mutable</span> std::shared_timed_mutex mutex_;</span><br><span class="line">    <span class="type">int</span> value_;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadSafe</span>() &#123;</span><br><span class="line">        value_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">std::shared_lock&lt;std::shared_timed_mutex&gt; <span class="title">loc</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::shared_timed_mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        value_ += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>std::exchange</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U </span>= T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">exchange</span><span class="params">(T&amp; obj, U&amp;&amp; new_value)</span> </span>&#123;</span><br><span class="line">    T old_value = std::<span class="built_in">move</span>(obj);</span><br><span class="line">    obj = std::forward&lt;U&gt;(new_value);</span><br><span class="line">    <span class="keyword">return</span> old_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用new_value替换obj的值，并返回obj的旧值。要求T必须满足可移动构造的要求，而且必须能移动复制U类型对象给T类型对象。</p>
<p>使用方法为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    std::<span class="built_in">exchange</span>(v, &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a : v) &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>   C++ 17: 构造函数模板推导，结构化绑定，if-switch语句初始化，内联变量，折叠表达式，constexpr lambda表达式，namespace嵌套，__has_include预处理表达式，lambda使用*this捕获对象副本，新增Attribute，字符串转换，std::variant，std::optional，std::any，std::apply，std::make_from_tuple，as_const，std::string_view，file_system，std::shared_mutex</p>
<p><strong>构造函数模板推导</strong></p>
<p>   <strong>结构化绑定</strong></p>
<p>   <strong>if-switch语句初始化</strong></p>
<p>   <strong>内联变量</strong></p>
<p>   <strong>折叠表达式</strong></p>
<p>   <strong>constexpr lambda表达式</strong></p>
<p>   <strong>namespace嵌套</strong></p>
<p>   <strong>__has_include预处理表达式</strong></p>
<p>   <strong>lambda使用*this捕获对象副本</strong></p>
<p>   <strong>新增Attribute</strong></p>
<p>   <strong>字符串转换</strong></p>
<p>   <strong>std::variant</strong></p>
<p>   <strong>std::optional</strong></p>
<p>   <strong>std::any</strong></p>
<p>   <strong>std::apply</strong></p>
<p>   <strong>std::make_from_tuple</strong></p>
<p>   <strong>as_const</strong></p>
<p>   <strong>std::string_view</strong></p>
<p>   <strong>file_system</strong></p>
<p>   <strong>std::shared_mutex</strong></p>
<ol start="2">
<li><p><strong>智能指针是怎么实现的</strong></p>
<ul>
<li><p><code>unique_ptr</code>：拥有对持有对象的唯一所有权。</p>
<p>1、get() 获取其保存的原生指针，尽量不要使用</p>
<p>2、bool() 判断是否拥有指针</p>
<p>3、release() 释放所管理指针的所有权，返回原生指针。但并不销毁原生指针。</p>
<p>4、reset() 释放并销毁原生指针。如果参数为一个新指针，将管理这个新指针</p>
<p>unique_ptr拥有对持有对象的唯一所有权的实现方式是将<strong>拷贝构造函数和赋值运算符删除delete</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Disable copy from lvalue.</span></span><br><span class="line"><span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>shared_ptr</code>：共享共享所有权的所有权。通过引用计数的方式管理指针，当引用计数为 0 时会销毁拥有的原生对象。</p>
<p>1、get() 获取其保存的原生指针，尽量不要使用</p>
<p>2、bool() 判断是否拥有指针</p>
<p>3、reset() 释放并销毁原生指针。如果参数为一个新指针，将管理这个新指针</p>
<p>4、unique() 如果引用计数为 1，则返回 true，否则返回 false</p>
<p>5、use_count() 返回引用计数的大小</p>
<p>主要有这两个成员变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element_type*	   _M_ptr;         <span class="comment">// Contained pointer.</span></span><br><span class="line">__shared_count&lt;_Lp&gt;  _M_refcount;    <span class="comment">// Reference counter.</span></span><br></pre></td></tr></table></figure>

<p>其中element_type是原生指针，_shared_count是引用器，底层使用<strong>原子类型</strong><code>Atomic_word</code>进行计数。</p>
</li>
<li><p><code>weak_ptr</code>：为了配合<code>shared_ptr</code>而存在。本身是一个弱指针，因为它本身是不能直接调用原生指针的方法的。如果想要使用原生指针的方法，需要将其先转换为一个<code>shared_ptr</code>。解决循环引用的问题</p>
<p>1、expired() 判断所指向的原生指针是否被释放，如果被释放了返回 true，否则返回 false</p>
<p>2、use_count() 返回原生指针的引用计数</p>
<p>3、lock() 返回 shared_ptr，如果原生指针没有被释放，则返回一个非空的 shared_ptr，否则返回一个空的 shared_ptr</p>
<p>4、reset() 将本身置空</p>
<p><code>weak_ptr</code>是<code>unique_ptr</code>的友元类。未实现<code>-&gt;</code>因此不能直接使用。</p>
</li>
</ul>
<p><code>-&gt;</code>表示用于调用指针原有的方法，而<code>.</code>则表示调用智能指针本身的方法。</p>
</li>
<li><p>STL都有哪些容器，底层实现是什么</p>
<ol>
<li><strong>vector</strong>（动态数组）：vector是一个<strong>动态数组</strong>，底层实现是使用连续的内存块存储元素。当元素数量超过当前分配的内存空间时，会重新分配更大的内存空间，并将原来的元素复制到新的内存空间中。</li>
<li><strong>list</strong>（双向链表）：list是一个<strong>双向链表</strong>，底层实现是使用节点来存储元素，并使用指针链接节点。由于是链表结构，list在插入和删除元素时效率较高，但随机访问元素的效率较低。</li>
<li><strong>forward_list</strong>（单向链表）：forward_list底层是使用单向链表实现。</li>
<li><strong>deque</strong>（双端队列）：deque是一个双端队列，底层实现是使用<strong>多个连续的内存块</strong>存储元素。deque允许在两端进行高效的插入和删除操作，并且支持随机访问元素。</li>
<li><strong>stack</strong>（栈）：stack是一个后进先出（LIFO）的容器，底层实现可以使用<strong>vector、deque或list</strong>来存储元素。通常使用<strong>deque</strong>作为底层实现。</li>
<li><strong>queue</strong>（队列）：queue是一个先进先出（FIFO）的容器，底层实现可以使用<strong>deque或list</strong>来存储元素。</li>
<li><strong>priority_queue</strong>（优先队列）：priority_queue是一个优先队列，底层实现通常使用<strong>vector或deque来存储元素，并使用堆（heap）数据结构</strong>来维护元素的优先级。</li>
<li><strong>set</strong>（集合）：set是一个有序的集合，底层实现通常使用<strong>红黑树</strong>（Red-Black Tree）数据结构来存储元素。set中的元素是唯一的，且按照一定的顺序进行排序。</li>
<li><strong>multiset</strong>（多重集合）：multiset是一个有序的多重集合，底层实现与set相同，但允许存储重复的元素。</li>
<li><strong>map</strong>（映射）：map是一个有序的键值对容器，底层实现通常使用<strong>红黑树</strong>数据结构来存储键值对。map中的键是唯一的，且按照一定的顺序进行排序。</li>
<li><strong>multimap</strong>（多重映射）：multimap是一个有序的多重映射，底层实现与map相同，但允许存储重复的键值对。</li>
<li><strong>unordered_set,unordered_map,unordered_multiset,uordered_multimap</strong>：底层使用hash表实现。</li>
</ol>
</li>
<li><p>移动语义是什么，std:move，std:forward</p>
<p>通过引入右值引用，移动构造函数，移动赋值运算符来避免拷贝操作，这就是移动语义。移动语义实际上是改变对象的所有权，适用于原变量不会再使用的情况。<br><code>std::move</code>将左值转换为右值。</p>
<p><code>std::forward</code>还原参数的左右值属性。因为在函数体中，不管是左值引用还是右值引用都是左值。</p>
<p>源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// remove_reference, 模板特化实现去除引用</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">remove_reference</span></span><br><span class="line">    &#123; <span class="keyword">typedef</span> _Tp   type; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">remove_reference</span>&lt;_Tp&amp;&gt;</span><br><span class="line">    &#123; <span class="keyword">typedef</span> _Tp   type; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">remove_reference</span>&lt;_Tp&amp;&amp;&gt;</span><br><span class="line">    &#123; <span class="keyword">typedef</span> _Tp   type; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//std::move， static_cast强制转换为右值</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function">    <span class="title">move</span><span class="params">(_Tp&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//std::forward，模板特化，引用折叠，static_cast负责转换</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function">    <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function">    <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="built_in">static_assert</span>(!std::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">&quot;template argument&quot;</span></span><br><span class="line">		    <span class="string">&quot; substituting _Tp is an lvalue reference type&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>你知道设计模式吗</strong></p>
<p>设计模式是前人经验总结的常用编码模板，有助于设计出可维护、可扩展、可重用的代码。</p>
<ul>
<li><strong>创建型模式</strong>：对类的实例化过程进行了抽象，能够将软件模块中<strong>对象的创建</strong>和对象的使用分离。<br>工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式</li>
<li><strong>结构性模式</strong>：关注于对象的组成以及对象之间的依赖关系，描述如何将类或者对象结合在一起形成更大的结构，就像<strong>搭积木</strong>，可以通过简单积木的组合形成复杂的、功能更为强大的结构。<br>适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式</li>
<li><strong>行为型模式</strong>：关注于对象的行为问题，是对在不同的对象之间划分责任和算法的抽象化；不仅仅关注类和对象的结构，而且重点关注它们之间的<strong>相互作用</strong>。<br>策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</li>
</ul>
<p><strong>工厂模式</strong></p>
<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
<p><strong>抽象工厂模式</strong></p>
<p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。</p>
<p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<p><strong>单例模式</strong></p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p><strong>建造者模式（构建者模式）</strong></p>
<p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。</p>
<p>一个Builder类会一步一步构造最终的对象。该Builder类是独立于其他对象的。</p>
<p>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>
<p><strong>原型模式</strong></p>
<p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。</p>
<p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p>
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<p><strong>适配器模式</strong></p>
<p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。</p>
<p>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。</p>
<p>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p><strong>装饰器模式</strong></p>
<p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。</p>
<p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p>
<p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p>
<p><strong>代理模式</strong></p>
<p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。</p>
<p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p>
<p>为其他对象提供一种代理以控制对这个对象的访问。</p>
<p>注意事项：</p>
<p>1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。</p>
<p>2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</p>
<p><strong>外观模式</strong></p>
<p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。</p>
<p>这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。</p>
<p>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<p><strong>桥接模式</strong></p>
<p>桥接模式（Bridge Pattern）是用于把抽象化与实现化解耦，使得二者可以独立变化。它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p>
<p>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p>
<p>将抽象部分与实现部分分离，使它们都可以独立的变化。</p>
<p>又称为柄体（Handle and Body）模式或接口（Interface）模式。</p>
<p>注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。</p>
<p><strong>组合模式</strong></p>
<p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了<strong>对象组的树形结构</strong>。</p>
<p>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</p>
<p>将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p><strong>享元模式</strong></p>
<p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p>
<p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。</p>
<p>运用共享技术有效地支持大量细粒度的对象。</p>
<p><strong>策略模式</strong></p>
<p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。</p>
<p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的context对象。策略对象改变context对象的执行算法。</p>
<p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。</p>
<p><strong>模板模式</strong></p>
<p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式&#x2F;模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。</p>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p><strong>观察者模式</strong></p>
<p>当对象间存在一对多关系时，则使用观察者模式（ObserverPattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。</p>
<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p><strong>迭代器模式</strong></p>
<p>迭代器模式（Iterator Pattern）是Java和.Net编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p>
<p>迭代器模式属于行为型模式。</p>
<p>提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示。</p>
<p><strong>责任链模式</strong></p>
<p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。</p>
<p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p>
<p>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>
<p><strong>命令模式</strong></p>
<p>命令模式（Command Pattern）是一种数据驱动的设计模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p>
<p>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p>
<p><strong>备忘录模式</strong></p>
<p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。</p>
<p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
<p><strong>状态模式</strong></p>
<p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。</p>
<p>在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的context对象。</p>
<p>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p>
<p><strong>访问者模式</strong></p>
<p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p>
<p>主要将数据结构与数据操作分离。</p>
<p>主要解决：稳定的数据结构和易变的操作耦合问题。</p>
<p><strong>中介者模式</strong></p>
<p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。</p>
<p>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<p><strong>解释器模式</strong></p>
<p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在SQL解析、符号处理引擎等。</p>
<p>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p>
</li>
<li><p><code>std:lock_guard</code>和<code>std::unique_lock</code></p>
<p>相同点：通过构造函数和析构函数控制锁的作用范围。创建时加锁，离开作用域时解锁。</p>
<p>不同点：<code>std::unique_lock</code>可以在构造函数中延时加锁，在需要时可以手动加锁和解锁。<code>std::locak_guard</code>不支持赋值操作。<code>std::unique_lock</code>支持可移动赋值，若占有互斥量则解锁并取得另一者的所有权。<code>std::unique_lock</code>更加灵活，但消耗的资源要多一些，因为要维持mutex的状态。<code>std::locak_guard</code>资源消耗相对小一点。</p>
</li>
<li><p>红黑树是什么</p>
<p>红黑树是一种自平衡的二叉搜索树，它在每个节点上增加了一个额外的属性，用于表示节点的颜色，可以是红色或黑色。</p>
<p>本质上是B树的二叉化，B树的某个节点中一个元素转化为黑节点，其他元素转化为红节点。</p>
<p>性质：</p>
<ol>
<li>每一个结点都有一个颜色，要么为红色，要么为黑色；</li>
<li>树的根结点为黑色；</li>
<li>树中不存在两个相邻的红色结点（即红色结点的父结点和孩子结点均不能是红色）；</li>
<li>从任意一个结点（包括根结点）到其任何后代 NULL 结点（默认是黑色的）的每条路径都具有相同数量的黑色结点。<br>与AVL树不同的是：插入删除不需要频繁的旋转，AVL树更平衡。</li>
</ol>
</li>
<li><p>算法题：环形子数组的最大和，力扣918原题，<strong>42&#x2F;43</strong></p>
<ul>
<li>思路：不考虑首尾相连计算得到一个结果，只考虑首尾相连计算得到一个结果，取较大值<br>用dp得到单个数组中最大子数组和。<strong>maxSuffix存储当前下标之后的后缀最大子数组和</strong>，每个元素与前缀计算首尾相连的子数组和。二者取较大值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp = <span class="number">-1</span>, res = INT_MIN;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSuffix</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(i == nums.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">                maxSuffix[i] = nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                maxSuffix[i] = <span class="built_in">max</span>(sum, maxSuffix[i+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> prefix = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                dp += nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; nums.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">                prefix += nums[i];</span><br><span class="line">                res = <span class="built_in">max</span>(res, prefix + maxSuffix[i+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首尾相连的情况下，总和减去最小子数组和即可得到包含首尾的最大子数组和。需要特殊考虑数组全为负时包含首尾的最大子数组和就是第一个元素和最后一个元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp_max = <span class="number">0</span>, res_max = INT_MIN, \</span><br><span class="line">        total = <span class="number">0</span>, dp_min = <span class="number">0</span>, res_min = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp_max &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                dp_max += nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp_max = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            res_max = <span class="built_in">max</span>(res_max, dp_max);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dp_min &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                dp_min += nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp_min = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            res_min = <span class="built_in">min</span>(res_min, dp_min);</span><br><span class="line">            total += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(total == res_min)&#123;</span><br><span class="line">            res_min = total - nums[<span class="number">0</span>] - nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res_max, total - res_min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
</li>
</ol>
<p><img src="/R.b49dbddffaa692d75988e0c5882daccarik=r6IIYs2muimY7A&riu=http://www.quazero.com/uploads/allimg/140529/1-140529145A4.jpeg" alt="美丽自然山水美景高清图片,高清图片,手机锁屏桌面-壁纸族"></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>John Doe</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://example.com/2023/08/05/8-3-%E5%85%83%E6%88%8E%E5%90%AF%E8%A1%8C%E4%B8%80%E9%9D%A2/">http://example.com/2023/08/05/8-3-%E5%85%83%E6%88%8E%E5%90%AF%E8%A1%8C%E4%B8%80%E9%9D%A2/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E5%85%83%E6%88%8E%E5%90%AF%E8%A1%8C/"># 元戎启行</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/08/09/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">IO多路复用</a>
            
            
            <a class="next" rel="next" href="/2023/08/05/hello-world/">Hello World</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© John Doe | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>